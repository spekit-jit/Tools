<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Content Mapping</title>
<meta name="color-scheme" content="light dark" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  :root {
    --bg: #f5f5f5; --panel: #ffffff; --ink: #111111; --muted: #666666;
    --accent: #4A3AFF; --ring: rgba(0,0,0,.2);
    --radius: 8px; --shadow: 0 4px 12px rgba(0,0,0,.1);
    --font: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  }
  @media (prefers-color-scheme: dark) {
    :root { --bg: #1a1a1a; --panel: #222222; --ink: #ffffff; --muted: #888888; --ring: rgba(255,255,255,.2); }
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; overflow: auto; }
  body {
    font-family: var(--font); color: var(--ink); background: var(--bg);
    display: flex; align-items: flex-start; justify-content: center;
  }
  .wrap {
    width: 100%; max-width: 1000px; padding: 20px; margin: 20px;
    background: var(--panel); border: 1px solid var(--ring); border-radius: var(--radius);
    box-shadow: var(--shadow); position: relative;
    transform-origin: top center;
  }
  .bar {
    display: flex; gap: 10px; align-items: center; justify-content: space-between;
    margin-bottom: 20px; flex-wrap: wrap; position: sticky; top: 0; z-index: 10;
    background: var(--panel); padding: 10px 0;
  }
  .zoom-controls { display: flex; gap: 8px; }
  .ghost, .primary {
    border: 1px solid var(--ring); padding: 10px 14px; border-radius: var(--radius);
    font-weight: 600; cursor: pointer; background: var(--panel); color: var(--ink);
  }
  .primary { background: var(--accent); color: #fff; }
  .ghost:hover, .primary:hover { background: var(--accent); color: #fff; }
  .parent {
    position: relative; background: var(--panel); border: 1px solid var(--ring);
    border-radius: var(--radius); padding: 16px; margin: 20px 0;
  }
  .parent-head { display: flex; align-items: center; gap: 10px; justify-content: center; }
  .btn {
    padding: 10px 16px; min-height: 40px; border-radius: var(--radius); border: 1px solid var(--ring);
    color: var(--ink); font-weight: 600; text-align: center; max-width: 300px;
    cursor: text; background: var(--panel);
  }
  .btn:focus { box-shadow: 0 0 0 2px var(--accent); }
  .btn.small { min-height: 36px; padding: 8px 12px; font-weight: 500; max-width: 260px; font-size: 15px; }
  .btn.tiny { min-height: 32px; padding: 6px 10px; font-weight: 400; max-width: 220px; font-size: 14px; }
  .btn[contenteditable="true"] { caret-color: var(--accent); }
  .act {
    width: 32px; height: 32px; border-radius: var(--radius); border: 1px solid var(--ring);
    background: var(--panel); color: var(--ink); cursor: pointer; font-weight: 600;
    display: none;
  }
  .parent-head.active .act, .chip.active .act { display: inline-flex; }
  .act:hover { background: var(--accent); color: #fff; }
  .subs { margin-top: 16px; }
  .subs-row, .subsubs-row { display: grid; grid-auto-flow: column; gap: 12px; justify-content: center; }
  .chip {
    display: flex; flex-direction: column; align-items: center; gap: 8px;
    background: var(--panel); border: 1px solid var(--ring); padding: 10px; border-radius: var(--radius);
  }
  .chip .actions { display: flex; gap: 6px; justify-content: center; }
  .chip .mini { width: 28px; height: 28px; font-size: 13px; }
  .tiny-text { color: var(--muted); font-size: 12px; margin-top: 10px; text-align: center; }
  path { stroke: var(--accent); stroke-width: 3; stroke-opacity: 0.9; stroke-linecap: round; fill: none; }
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="bar">
    <div class="zoom-controls">
      <button id="zoomIn" class="ghost mini" title="Zoom in">+</button>
      <button id="zoomOut" class="ghost mini" title="Zoom out">‚àí</button>
      <button id="zoomReset" class="ghost mini" title="Reset zoom">‚Ü∫</button>
    </div>
    <div>
      <button id="addParent" class="primary">+ Add parent topic</button>
      <button id="clearBtn" class="ghost" title="Clear the entire map">üóë Clear</button>
      <button id="exportPdfBtn" class="ghost" title="Export map as PDF">üìÑ Export PDF</button>
    </div>
  </div>
  <div id="board"></div>
  <div class="tiny-text">Tip: Click a pill to edit and show action buttons. Parent ‚Äú+‚Äù adds a sub-topic. Sub-topic ‚Äú+‚Äù adds a sub-sub-topic. Buttons: ‚Üê left, ‚Üí right, √ó delete. Use zoom controls or wheel/pinch to adjust view.</div>
</div>

<script>
try {
  const { jsPDF } = window.jspdf;
  const board = document.getElementById('board');
  if (!board) throw new Error('Board element not found');
  const wrap = document.getElementById('wrap');
  if (!wrap) throw new Error('Wrap element not found');
  const addParentBtn = document.getElementById('addParent');
  if (!addParentBtn) throw new Error('Add parent button not found');
  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const zoomResetBtn = document.getElementById('zoomReset');
  const clearBtn = document.getElementById('clearBtn');
  const exportPdfBtn = document.getElementById('exportPdfBtn');
  if (!zoomInBtn || !zoomOutBtn || !zoomResetBtn || !clearBtn || !exportPdfBtn) {
    throw new Error('Control buttons not found');
  }

  let parentId = 0;
  let parents = [];
  let zoomLevel = 1;
  const zoomMin = 0.5;
  const zoomMax = 2;
  const zoomStep = 0.1;

  function makeEditablePill(text, key, size = 'normal') {
    const el = document.createElement('div');
    el.className = `btn ${size === 'small' ? 'small' : size === 'tiny' ? 'tiny' : ''}`;
    el.dataset.id = key;
    el.contentEditable = 'true';
    el.spellcheck = false;
    el.textContent = text;
    el.addEventListener('click', () => {
      console.log(`Pill clicked: ${key}`);
      el.focus();
      const parent = el.closest('.parent-head, .chip');
      if (parent) parent.classList.add('active');
      const range = document.createRange();
      range.selectNodeContents(el);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    });
    el.addEventListener('blur', () => {
      console.log(`Pill blurred: ${key}`);
      const parent = el.closest('.parent-head, .chip');
      if (parent) parent.classList.remove('active');
    });
    el.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        el.blur();
      }
    });
    return el;
  }

  function newParentModel() {
    return { id: `p${++parentId}`, title: 'parent topic', subs: [] };
  }
  function newSubModel() {
    return { id: `s${Math.random().toString(36).slice(2, 8)}`, title: 'sub-topic', subsubs: [] };
  }
  function newSubSubModel() {
    return { id: `ss${Math.random().toString(36).slice(2, 8)}`, title: 'sub-sub-topic' };
  }

  function renderParent(model) {
    try {
      const wrap = document.createElement('section');
      wrap.className = 'parent';
      wrap.dataset.pid = model.id;

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.style.position = 'absolute';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';
      svg.style.pointerEvents = 'none';
      svg.style.overflow = 'visible';

      const head = document.createElement('div');
      head.className = 'parent-head';

      const pill = makeEditablePill(model.title, model.id);
      pill.addEventListener('input', () => {
        model.title = pill.textContent.trim() || 'parent topic';
      });
      pill.addEventListener('blur', () => {
        pill.textContent = model.title;
        drawLines();
      });
      head.appendChild(pill);

      const addSub = document.createElement('button');
      addSub.className = 'act';
      addSub.title = 'Add sub-topic';
      addSub.textContent = '+';
      addSub.addEventListener('click', () => {
        console.log('Add sub-topic button clicked');
        try {
          const newSub = newSubModel();
          model.subs.push(newSub);
          renderSubs(newSub.id);
        } catch (e) {
          console.error('Failed to add sub-topic:', e);
          alert('Error adding sub-topic.');
        }
      });
      head.appendChild(addSub);

      const deleteParent = document.createElement('button');
      deleteParent.className = 'act';
      deleteParent.title = 'Delete this parent topic';
      deleteParent.textContent = '√ó';
      deleteParent.addEventListener('click', () => {
        console.log('Delete parent button clicked');
        try {
          if (confirm('Delete this parent topic and all its sub-topics?')) {
            const index = parents.findIndex(p => p.id === model.id);
            if (index > -1) parents.splice(index, 1);
            board.removeChild(wrap);
          }
        } catch (e) {
          console.error('Failed to delete parent:', e);
          alert('Error deleting parent.');
        }
      });
      head.appendChild(deleteParent);

      const subs = document.createElement('div');
      subs.className = 'subs';

      function renderSubs(newId = null) {
        try {
          subs.innerHTML = '';
          svg.innerHTML = '';
          const rowEl = document.createElement('div');
          rowEl.className = 'subs-row';
          model.subs.forEach((sub, index) => {
            const chip = document.createElement('div');
            chip.className = 'chip';

            const sp = makeEditablePill(sub.title, sub.id, 'small');
            sp.addEventListener('input', () => {
              sub.title = sp.textContent.trim() || 'sub-topic';
            });
            sp.addEventListener('blur', () => {
              sp.textContent = sub.title;
              drawLines();
            });
            chip.appendChild(sp);

            const actions = document.createElement('div');
            actions.className = 'actions';

            const left = document.createElement('button');
            left.className = 'mini act';
            left.title = 'Add sub-topic to the left';
            left.textContent = '‚Üê';
            left.addEventListener('click', () => {
              console.log('Add sub-topic left button clicked');
              try {
                const newSub = newSubModel();
                model.subs.splice(index, 0, newSub);
                renderSubs(newSub.id);
              } catch (e) {
                console.error('Failed to add sub-topic left:', e);
                alert('Error adding sub-topic.');
              }
            });

            const right = document.createElement('button');
            right.className = 'mini act';
            right.title = 'Add sub-topic to the right';
            right.textContent = '‚Üí';
            right.addEventListener('click', () => {
              console.log('Add sub-topic right button clicked');
              try {
                const newSub = newSubModel();
                model.subs.splice(index + 1, 0, newSub);
                renderSubs(newSub.id);
              } catch (e) {
                console.error('Failed to add sub-topic right:', e);
                alert('Error adding sub-topic.');
              }
            });

            const addSubSub = document.createElement('button');
            addSubSub.className = 'mini act';
            addSubSub.title = 'Add sub-sub-topic';
            addSubSub.textContent = '+';
            addSubSub.addEventListener('click', () => {
              console.log('Add sub-sub-topic button clicked');
              try {
                const newSubSub = newSubSubModel();
                sub.subsubs.push(newSubSub);
                renderSubs(newSubSub.id);
              } catch (e) {
                console.error('Failed to add sub-sub-topic:', e);
                alert('Error adding sub-sub-topic.');
              }
            });

            const del = document.createElement('button');
            del.className = 'mini act';
            del.title = 'Delete this sub-topic';
            del.textContent = '√ó';
            del.addEventListener('click', () => {
              console.log('Delete sub-topic button clicked');
              try {
                if (confirm('Delete this sub-topic and its sub-sub-topics?')) {
                  model.subs.splice(index, 1);
                  renderSubs();
                }
              } catch (e) {
                console.error('Failed to delete sub-topic:', e);
                alert('Error deleting sub-topic.');
              }
            });

            actions.append(left, right, addSubSub, del);
            chip.appendChild(actions);

            const subsubs = document.createElement('div');
            subsubs.className = 'subsubs-row';
            sub.subsubs.forEach((subsub, ssIndex) => {
              const subsubChip = document.createElement('div');
              subsubChip.className = 'chip';

              const ssp = makeEditablePill(subsub.title, subsub.id, 'tiny');
              ssp.addEventListener('input', () => {
                subsub.title = ssp.textContent.trim() || 'sub-sub-topic';
              });
              ssp.addEventListener('blur', () => {
                ssp.textContent = subsub.title;
                drawLines();
              });
              subsubChip.appendChild(ssp);

              const subsubActions = document.createElement('div');
              subsubActions.className = 'actions';

              const ssLeft = document.createElement('button');
              ssLeft.className = 'mini act';
              ssLeft.title = 'Add sub-sub-topic to the left';
              ssLeft.textContent = '‚Üê';
              ssLeft.addEventListener('click', () => {
                console.log('Add sub-sub-topic left button clicked');
                try {
                  const newSubSub = newSubSubModel();
                  sub.subsubs.splice(ssIndex, 0, newSubSub);
                  renderSubs(newSubSub.id);
                } catch (e) {
                  console.error('Failed to add sub-sub-topic left:', e);
                  alert('Error adding sub-sub-topic.');
                }
              });

              const ssRight = document.createElement('button');
              ssRight.className = 'mini act';
              ssRight.title = 'Add sub-sub-topic to the right';
              ssRight.textContent = '‚Üí';
              ssRight.addEventListener('click', () => {
                console.log('Add sub-sub-topic right button clicked');
                try {
                  const newSubSub = newSubSubModel();
                  sub.subsubs.splice(ssIndex + 1, 0, newSubSub);
                  renderSubs(newSubSub.id);
                } catch (e) {
                  console.error('Failed to add sub-sub-topic right:', e);
                  alert('Error adding sub-sub-topic.');
                }
              });

              const ssDel = document.createElement('button');
              ssDel.className = 'mini act';
              ssDel.title = 'Delete this sub-sub-topic';
              ssDel.textContent = '√ó';
              ssDel.addEventListener('click', () => {
                console.log('Delete sub-sub-topic button clicked');
                try {
                  if (confirm('Delete this sub-sub-topic?')) {
                    sub.subsubs.splice(ssIndex, 1);
                    renderSubs();
                  }
                } catch (e) {
                  console.error('Failed to delete sub-sub-topic:', e);
                  alert('Error deleting sub-sub-topic.');
                }
              });

              subsubActions.append(ssLeft, ssRight, ssDel);
              subsubChip.appendChild(subsubActions);
              subsubs.appendChild(subsubChip);
            });
            chip.appendChild(subsubs);
            rowEl.appendChild(chip);
          });
          subs.appendChild(rowEl);
          drawLines();
          if (newId) {
            const newPill = subs.querySelector(`.btn[data-id="${newId}"]`);
            if (newPill) {
              newPill.focus();
              newPill.closest('.chip').classList.add('active');
            }
          }
        } catch (e) {
          console.error('Failed to render subs:', e);
          alert('Error rendering sub-topics.');
        }
      }

      function drawLines() {
        try {
          const wrapRect = wrap.getBoundingClientRect();
          const parentRect = pill.getBoundingClientRect();
          const parentCenterX = (parentRect.left - wrapRect.left + parentRect.width / 2) / zoomLevel;
          const parentBottomY = (parentRect.bottom - wrapRect.top + 8) / zoomLevel;

          svg.innerHTML = '';
          const subPills = subs.querySelectorAll('.btn.small');
          subPills.forEach(sp => {
            const spRect = sp.getBoundingClientRect();
            const spCenterX = (spRect.left - wrapRect.left + spRect.width / 2) / zoomLevel;
            const spTopY = (spRect.top - wrapRect.top - 8) / zoomLevel;
            const midY = parentBottomY + (spTopY - parentBottomY) * 0.3;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M${parentCenterX},${parentBottomY} C${parentCenterX},${midY} ${spCenterX},${midY} ${spCenterX},${spTopY}`);
            path.setAttribute('stroke-width', '3');
            path.setAttribute('stroke-opacity', '0.9');
            svg.appendChild(path);

            const subsubPills = sp.parentElement.querySelectorAll('.btn.tiny');
            subsubPills.forEach(ssp => {
              const sspRect = ssp.getBoundingClientRect();
              const sspCenterX = (sspRect.left - wrapRect.left + sspRect.width / 2) / zoomLevel;
              const sspTopY = (sspRect.top - wrapRect.top - 8) / zoomLevel;
              const subBottomY = (spRect.bottom - wrapRect.top + 8) / zoomLevel;
              const subMidY = subBottomY + (sspTopY - subBottomY) * 0.3;

              const subPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              subPath.setAttribute('d', `M${spCenterX},${subBottomY} C${spCenterX},${subMidY} ${sspCenterX},${subMidY} ${sspCenterX},${sspTopY}`);
              subPath.setAttribute('stroke-width', '2');
              subPath.setAttribute('stroke-opacity', '0.9');
              svg.appendChild(subPath);
            });
          });
        } catch (e) {
          console.error('Failed to draw lines:', e);
        }
      }

      const resizeObserver = new ResizeObserver(() => {
        drawLines();
        wrap.style.minHeight = `${board.scrollHeight / zoomLevel + 100}px`;
      });
      resizeObserver.observe(board);

      renderSubs();
      wrap.append(svg, head, subs);
      return wrap;
    } catch (e) {
      console.error('Failed to render parent:', e);
      return null;
    }
  }

  function addParent(focus = true) {
    try {
      console.log('Add parent button clicked');
      if (!board) throw new Error('Board element is missing');
      const model = newParentModel();
      parents.push(model);
      const node = renderParent(model);
      if (!node) throw new Error('Failed to render parent node');
      board.appendChild(node);
      if (focus) {
        const pill = node.querySelector('.btn');
        if (pill) {
          pill.focus();
          pill.closest('.parent-head').classList.add('active');
        }
      }
      console.log('Parent added:', model.id);
    } catch (e) {
      console.error('Failed to add parent:', e);
      alert('Error adding parent topic. Check the console (F12).');
    }
  }

  function exportPDF() {
    try {
      console.log('Export PDF button clicked');
      document.querySelectorAll('.act').forEach(btn => btn.style.display = 'none');
      const pdfWrap = document.createElement('div');
      pdfWrap.style.background = 'white';
      pdfWrap.style.padding = '20px';
      pdfWrap.style.width = '794px';
      pdfWrap.innerHTML = board.innerHTML;
      pdfWrap.querySelectorAll('svg').forEach(svg => {
        svg.style.position = 'absolute';
        svg.style.width = '100%';
        svg.style.height = '100%';
      });
      document.body.appendChild(pdfWrap);
      html2canvas(pdfWrap, { scale: 2, backgroundColor: '#ffffff' }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const pdf = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'a4'
        });
        const imgWidth = 190;
        const imgHeight = (canvas.height * imgWidth) / canvas.width;
        let heightLeft = imgHeight;
        let position = 10;

        pdf.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
        heightLeft -= 277;

        while (heightLeft > 0) {
          pdf.addPage();
          position = heightLeft - imgHeight + 10;
          pdf.addImage(imgData, 'PNG', 10, position, imgWidth, imgHeight);
          heightLeft -= 277;
        }

        pdf.save('content-map.pdf');
        document.body.removeChild(pdfWrap);
        document.querySelectorAll('.act').forEach(btn => btn.style.display = '');
      }).catch(e => {
        console.error('Failed to generate PDF:', e);
        alert('Error generating PDF.');
        document.body.removeChild(pdfWrap);
        document.querySelectorAll('.act').forEach(btn => btn.style.display = '');
      });
    } catch (e) {
      console.error('Failed to export PDF:', e);
      alert('Error exporting PDF.');
    }
  }

  function clearMap() {
    try {
      console.log('Clear map button clicked');
      if (confirm('Clear the entire map? This cannot be undone.')) {
        board.innerHTML = '';
        parents = [];
        parentId = 0;
        addParent(false);
        zoomLevel = 1;
        wrap.style.transform = `scale(1)`;
      }
    } catch (e) {
      console.error('Failed to clear map:', e);
      alert('Error clearing map.');
    }
  }

  function updateZoom(newZoom) {
    console.log('Zoom updated:', newZoom);
    zoomLevel = Math.max(zoomMin, Math.min(zoomMax, newZoom));
    wrap.style.transform = `scale(${zoomLevel})`;
    wrap.style.minHeight = `${board.scrollHeight / zoomLevel + 100}px`;
    document.querySelectorAll('.parent').forEach(p => {
      drawLines();
    });
  }

  zoomInBtn.addEventListener('click', () => {
    console.log('Zoom in button clicked');
    updateZoom(zoomLevel + zoomStep);
  });
  zoomOutBtn.addEventListener('click', () => {
    console.log('Zoom out button clicked');
    updateZoom(zoomLevel - zoomStep);
  });
  zoomResetBtn.addEventListener('click', () => {
    console.log('Zoom reset button clicked');
    updateZoom(1);
  });

  wrap.addEventListener('wheel', (e) => {
    e.preventDefault();
    console.log('Wheel zoom triggered');
    const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
    updateZoom(zoomLevel + delta);
  });

  let lastDistance = 0;
  wrap.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      lastDistance = Math.hypot(
        e.touches[0].pageX - e.touches[1].pageX,
        e.touches[0].pageY - e.touches[1].pageY
      );
    }
  });
  wrap.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      console.log('Pinch zoom triggered');
      const distance = Math.hypot(
        e.touches[0].pageX - e.touches[1].pageX,
        e.touches[0].pageY - e.touches[1].pageY
      );
      const delta = (distance - lastDistance) / 1000;
      updateZoom(zoomLevel + delta);
      lastDistance = distance;
    }
  });

  addParentBtn.addEventListener('click', addParent);
  exportPdfBtn.addEventListener('click', exportPDF);
  clearBtn.addEventListener('click', clearMap);
  addParent(false);
  console.log('App initialized');
} catch (e) {
  console.error('Initialization failed:', e);
  alert('Error initializing app. Check the console (F12).');
}
</script>
</body>
</html>
