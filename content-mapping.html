<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Topic Mapper — Balanced Layout</title>
<style>
  :root{
    --bg:#fafafa; --panel:#fff; --text:#111; --muted:#666;
    --accent:#6a5cff; --accent-2:#ff7a59;
    --node-fill:#fff; --node-stroke:#e2e2e2;
    --node-parent:#eef0ff; --node-child:#fff9ef;
    --edge:#c7c7d0; --edge-active:var(--accent);
    --shadow:0 4px 14px rgba(0,0,0,.08);
    --radius:14px; --pad:14px;
    --font:-apple-system,system-ui,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#0f1115; --panel:#141821; --text:#f2f4f8; --muted:#9aa3b2;
      --accent:#8f88ff; --accent-2:#ffa37f;
      --node-fill:#1a2030; --node-stroke:#283047;
      --node-parent:#1d2440; --node-child:#221e18;
      --edge:#34405f; --edge-active:#a7a2ff;
      --shadow:0 6px 16px rgba(0,0,0,.35);
    }
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--font);display:flex;flex-direction:column;min-height:100%}
  .toolbar{position:sticky;top:0;z-index:10;background:var(--panel);box-shadow:var(--shadow);display:flex;gap:8px;align-items:center;padding:10px 12px;flex-wrap:wrap}
  .toolbar .title{font-weight:600;margin-right:auto;letter-spacing:.2px}
  button,label.btn{
    appearance:none;border:1px solid var(--node-stroke);background:var(--panel);color:var(--text);
    border-radius:10px;padding:8px 12px;cursor:pointer;font:inherit
  }
  button.primary{background:var(--accent);color:#fff;border-color:transparent}
  button:hover{filter:brightness(1.03)}
  button:disabled{opacity:.5;cursor:not-allowed}
  input[type=file]{display:none}
  .stage-wrap{position:relative;flex:1 1 auto;min-height:0}
  svg#stage{width:100%;height:100%;display:block;touch-action:none;background:
    radial-gradient(transparent 3px, transparent 3px) 0 0/40px 40px,
    radial-gradient(transparent 3px, transparent 3px) 20px 20px/40px 40px}
  .node>rect{fill:var(--node-fill);stroke:var(--node-stroke);stroke-width:1.5;rx:12;ry:12;filter:drop-shadow(0 3px 6px rgba(0,0,0,.08))}
  .node.parent>rect{fill:var(--node-parent)}
  .node.child>rect{fill:var(--node-child)}
  .node.selected>rect{stroke:var(--accent);stroke-width:2}
  .edge{stroke:var(--edge);stroke-width:2;fill:none}
  .edge.active{stroke:var(--edge-active);stroke-dasharray:4 4}
  .label{font-size:14px;fill:var(--text);user-select:none;pointer-events:none}
  .editor{position:absolute;z-index:20;background:var(--panel);color:var(--text);border:1px solid var(--node-stroke);
    border-radius:10px;padding:8px 10px;min-width:160px;box-shadow:var(--shadow);outline:none}
  .hint{position:absolute;right:10px;bottom:10px;opacity:.75;font-size:12px;color:var(--muted);background:var(--panel);
    padding:6px 8px;border-radius:8px;border:1px solid var(--node-stroke)}
  .spacer{flex:1}
</style>
</head>
<body>
  <div class="toolbar">
    <div class="title">Topic Mapper</div>
    <button id="addParent" class="primary">＋ Topic</button>
    <button id="addChild" disabled>＋ Subtopic</button>
    <button id="connect" disabled>⟷ Connect</button>
    <button id="autoLayout" class="">Auto Layout: On</button>
    <button id="zoomFit">Zoom to Fit</button>
    <button id="reset">Reset</button>
    <div class="spacer"></div>
    <button id="exportBtn">Export</button>
    <label for="importFile" class="btn">Import</label>
    <input id="importFile" type="file" accept="application/json" />
  </div>

  <div class="stage-wrap">
    <svg id="stage" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid meet">
      <g id="edges"></g>
      <g id="nodes"></g>
    </svg>
    <div class="hint">Tip: Double-click a node to rename. Auto Layout keeps things centered. Toggle it off to drag manually.</div>
  </div>

<script>
(() => {
  const stage = document.getElementById('stage');
  const gNodes = document.getElementById('nodes');
  const gEdges = document.getElementById('edges');

  const btnAddParent = document.getElementById('addParent');
  const btnAddChild  = document.getElementById('addChild');
  const btnConnect   = document.getElementById('connect');
  const btnZoomFit   = document.getElementById('zoomFit');
  const btnReset     = document.getElementById('reset');
  const btnExport    = document.getElementById('exportBtn');
  const fileImport   = document.getElementById('importFile');
  const btnAutoLayout= document.getElementById('autoLayout');

  const PADDING_X = 14, PADDING_Y = 10, MIN_W = 120, MIN_H = 40;
  const LEVEL_GAP_Y = 120;          // vertical spacing between levels
  const SIBLING_GAP_X = 40;         // minimal horizontal gap between siblings
  const SUBTREE_PAD_X = 20;         // extra padding around subtree width

  let nodes = [];   // {id,x,y,w,h,text,type,parentId?}
  let edges = [];   // {id,a,b}
  let selectedId = null;
  let isConnecting = false;
  let connectAnchor = null;
  let autoLayout = true;

  const id = () => Math.random().toString(36).slice(2,9);
  const findNode = nid => nodes.find(n => n.id === nid);
  const nodeEl = nid => document.getElementById('node-'+nid);
  const edgeEl = eid => document.getElementById('edge-'+eid);

  function buildNode(n){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.classList.add('node', n.type);
    g.setAttribute('id','node-'+n.id);
    g.setAttribute('transform',`translate(${n.x},${n.y})`);
    g.setAttribute('data-id', n.id);

    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('width', n.w); rect.setAttribute('height', n.h);

    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.classList.add('label');
    text.setAttribute('x', n.w/2); text.setAttribute('y', n.h/2);
    text.setAttribute('dominant-baseline','middle');
    text.setAttribute('text-anchor','middle');
    text.textContent = n.text;

    g.appendChild(rect); g.appendChild(text);
    attachNodeEvents(g);
    return g;
  }

  function drawNode(n){
    const existing = nodeEl(n.id);
    const g = existing || buildNode(n);
    if(!existing) gNodes.appendChild(g);
    g.setAttribute('transform',`translate(${n.x},${n.y})`);
    const rect = g.querySelector('rect');
    rect.setAttribute('width', n.w); rect.setAttribute('height', n.h);
    const label = g.querySelector('text');
    label.setAttribute('x', n.w/2); label.setAttribute('y', n.h/2);
    label.textContent = n.text;
    g.classList.toggle('selected', selectedId===n.id);
  }

  function drawEdge(e){
    let path = edgeEl(e.id);
    if(!path){
      path = document.createElementNS('http://www.w3.org/2000/svg','path');
      path.classList.add('edge');
      path.setAttribute('id','edge-'+e.id);
      gEdges.appendChild(path);
    }
    const a = findNode(e.a), b = findNode(e.b);
    if(!a || !b) return;
    const ax = a.x + a.w/2, ay = a.y + a.h;
    const bx = b.x + b.w/2, by = b.y; // connect bottom of parent to top of child when hierarchical

    // If hierarchical (b.parentId === a.id or a.parentId === b.id) use vertical-ish curve
    let y1 = ay, y2 = by;
    let dx = (bx-ax)*0.3, dy = (by-ay)*0.6;
    const d = `M ${ax} ${y1} C ${ax+dx} ${y1+dy}, ${bx-dx} ${y2-dy}, ${bx} ${y2}`;
    path.setAttribute('d', d);
  }

  function redraw(){
    edges.forEach(drawEdge);
    nodes.forEach(drawNode);
    fitViewBoxToContent();
    persist();
    updateButtons();
  }

  function autosizeNode(n){
    let ghost = document.getElementById('ghost-measure');
    if(!ghost){
      ghost = document.createElementNS('http://www.w3.org/2000/svg','text');
      ghost.setAttribute('id','ghost-measure');
      ghost.setAttribute('class','label');
      ghost.setAttribute('visibility','hidden');
      stage.appendChild(ghost);
    }
    ghost.textContent = n.text || ' ';
    const bb = ghost.getBBox();
    n.w = Math.max(MIN_W, Math.ceil(bb.width + PADDING_X*2));
    n.h = Math.max(MIN_H, Math.ceil(bb.height + PADDING_Y*2));
  }

  function fitViewBoxToContent(pad=80){
    if(nodes.length===0){
      stage.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight-64}`);
      return;
    }
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    for(const n of nodes){
      minX = Math.min(minX, n.x);
      minY = Math.min(minY, n.y);
      maxX = Math.max(maxX, n.x + n.w);
      maxY = Math.max(maxY, n.y + n.h);
    }
    minX -= pad; minY -= pad; maxX += pad; maxY += pad;
    const vbW = Math.max(320, maxX - minX);
    const vbH = Math.max(240, maxY - minY);
    stage.setAttribute('viewBox', `${minX} ${minY} ${vbW} ${vbH}`);
  }

  function select(nid){ selectedId = nid; updateButtons(); redraw(); }
  function clearSelection(){ selectedId=null; isConnecting=false; connectAnchor=null; updateButtons(); redraw(); }
  function updateButtons(){
    const hasSel = !!selectedId;
    btnAddChild.disabled = !hasSel;
    btnConnect.disabled  = !hasSel;
    btnAutoLayout.textContent = `Auto Layout: ${autoLayout ? 'On' : 'Off'}`;
  }

  function editNode(n){
    const wrap = document.querySelector('.stage-wrap');
    const editor = document.createElement('textarea');
    editor.className = 'editor';
    editor.value = n.text;
    wrap.appendChild(editor);

    const pt = stage.createSVGPoint();
    pt.x = n.x + n.w/2; pt.y = n.y + n.h/2;
    const ctm = stage.getScreenCTM();
    const sp = pt.matrixTransform(ctm);
    const approxW = Math.max(180, n.w + 20);
    const approxH = Math.max(48, n.h + 10);
    editor.style.left = (sp.x - approxW/2) + 'px';
    editor.style.top  = (sp.y - approxH/2) + 'px';
    editor.style.width = approxW + 'px';
    editor.style.height = approxH + 'px';

    editor.focus(); editor.setSelectionRange(0, editor.value.length);

    const commit = () => {
      n.text = editor.value.trim() || 'Topic';
      autosizeNode(n);
      wrap.removeChild(editor);
      if(autoLayout) layoutAndRedraw(); else redraw();
    };
    const cancel = () => { wrap.removeChild(editor); if(autoLayout) layoutAndRedraw(); else redraw(); };

    editor.addEventListener('keydown', (e)=>{
      if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); commit(); }
      if(e.key==='Escape'){ e.preventDefault(); cancel(); }
    });
    editor.addEventListener('blur', commit, {once:true});
  }

  function attachNodeEvents(g){
    let dragging = false;
    let start = {x:0,y:0}; let orig = {x:0,y:0};
    const nid = g.getAttribute('data-id');

    g.addEventListener('pointerdown', (e)=>{
      if(autoLayout) { select(nid); return; } // no dragging in auto mode
      e.preventDefault();
      g.setPointerCapture(e.pointerId);
      dragging = true;
      const n = findNode(nid);
      select(nid);
      start = {x:e.clientX,y:e.clientY};
      orig  = {x:n.x,y:n.y};
    });

    g.addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - start.x;
      const dy = e.clientY - start.y;
      const inv = stage.getScreenCTM().inverse();
      const p0 = stage.createSVGPoint(); p0.x=0; p0.y=0;
      const p1 = stage.createSVGPoint(); p1.x=dx; p1.y=dy;
      const s0 = p0.matrixTransform(inv);
      const s1 = p1.matrixTransform(inv);
      const sdx = s1.x - s0.x, sdy = s1.y - s0.y;

      const n = findNode(nid);
      n.x = orig.x + sdx; n.y = orig.y + sdy;
      drawNode(n);
      edges.forEach(e => (e.a===nid || e.b===nid) && drawEdge(e));
      fitViewBoxToContent();
    });

    const endDrag = (e)=>{
      if(!dragging) return;
      dragging=false; g.releasePointerCapture(e.pointerId);
      persist();
    };
    g.addEventListener('pointerup', endDrag);
    g.addEventListener('pointercancel', endDrag);

    g.addEventListener('dblclick', (e)=>{ e.preventDefault(); const n=findNode(nid); editNode(n); });

    g.addEventListener('click', (e)=>{
      if(!isConnecting) return;
      const targetId = nid;
      if(connectAnchor && connectAnchor!==targetId){
        addEdge(connectAnchor, targetId);
        isConnecting=false; connectAnchor=null;
        if(autoLayout) layoutAndRedraw(); else redraw();
      } else {
        connectAnchor = targetId;
        highlightConnecting(true, targetId);
      }
      e.stopPropagation();
    });
  }

  function highlightConnecting(active){ [...gEdges.children].forEach(p=>p.classList.toggle('active',active)); }

  function addNode({text='Topic',x=0,y=0,type='parent',parentId=null}={}){
    const n = {id:id(),text,x,y,w:MIN_W,h:MIN_H,type,parentId};
    autosizeNode(n);
    nodes.push(n);
    drawNode(n);
    select(n.id);
    persist();
    return n;
  }

  function addSubtopic(anchorId){
    const anchor = findNode(anchorId); if(!anchor) return;
    const child = addNode({text:'Subtopic',type:'child',parentId:anchor.id});
    addEdge(anchor.id, child.id);
    return child;
  }

  function addEdge(a,b){
    if(a===b) return;
    if(edges.some(e=> (e.a===a&&e.b===b)||(e.a===b&&e.b===a))) return;
    edges.push({id:id(),a,b});
    persist();
  }

  function removeAll(){
    nodes=[]; edges=[];
    gNodes.innerHTML=''; gEdges.innerHTML='';
    clearSelection();
    redraw();
  }

  const LS_KEY='topic-mapper-v3';
  function persist(){ try{ localStorage.setItem(LS_KEY, JSON.stringify({nodes,edges,autoLayout})); }catch{} }
  function restore(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const parsed = JSON.parse(raw);
      if(parsed?.nodes && parsed?.edges){ nodes=parsed.nodes; edges=parsed.edges; }
      if(typeof parsed?.autoLayout==='boolean') autoLayout = parsed.autoLayout;
    }catch{}
  }

  function exportJSON(){
    const blob = new Blob([JSON.stringify({nodes,edges},null,2)],{type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='topic-map.json';
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),1000);
  }

  function importJSON(file){
    const reader=new FileReader();
    reader.onload=()=>{
      try{
        const data=JSON.parse(reader.result);
        if(Array.isArray(data.nodes)&&Array.isArray(data.edges)){
          nodes=data.nodes; edges=data.edges;
          gNodes.innerHTML=''; gEdges.innerHTML='';
          nodes.forEach(n=>autosizeNode(n));
          if(autoLayout) layoutAndRedraw(); else { nodes.forEach(drawNode); edges.forEach(drawEdge); fitViewBoxToContent(); persist(); }
        }
      }catch{ alert('Invalid JSON'); }
    };
    reader.readAsText(file);
  }

  // ---------- Balanced downward auto layout ----------
  // We treat parentId relations as the hierarchy. Any node without a parentId becomes a root.
  // Width assignment is based on subtree size (number of leaves), giving balanced spacing.

  function buildHierarchy(){
    const map = new Map(nodes.map(n=>[n.id,{...n, children:[] }]));
    const hasParent = new Set();
    for(const n of map.values()){
      if(n.parentId && map.has(n.parentId)){
        map.get(n.parentId).children.push(n);
        hasParent.add(n.id);
      }
    }
    const roots = [...map.values()].filter(n => !hasParent.has(n.id));
    return {map, roots};
  }

  function measureSubtree(node){
    if(!node.children || node.children.length===0){
      node._subWidth = Math.max(node.w + SUBTREE_PAD_X, MIN_W) + SIBLING_GAP_X; // leaf width
      node._leaves = 1;
      return node._subWidth;
    }
    let sum = 0;
    for(const c of node.children){
      sum += measureSubtree(c);
    }
    node._leaves = node.children.reduce((a,c)=>a+c._leaves,0);
    // Make parent at least as wide as its box
    node._subWidth = Math.max(sum, (node.w + SUBTREE_PAD_X) + SIBLING_GAP_X);
    return node._subWidth;
  }

  function placeSubtree(node, leftX, topY){
    // Node x is centered over its children span (or over its own width if leaf)
    let childrenSpanLeft = leftX;
    if(node.children && node.children.length){
      for(const c of node.children){
        placeSubtree(c, childrenSpanLeft, topY + node.h + LEVEL_GAP_Y);
        childrenSpanLeft += c._subWidth;
      }
      // center node over children block
      const first = node.children[0];
      const last  = node.children[node.children.length-1];
      const left  = first.x;
      const right = last.x + last.w;
      node.x = (left + right)/2 - node.w/2;
      node.y = topY;
    }else{
      // leaf
      node.x = leftX + (node._subWidth/2) - node.w/2;
      node.y = topY;
    }
  }

  function layoutAndRedraw(){
    // Ensure sizes are up to date
    nodes.forEach(autosizeNode);

    const {map, roots} = buildHierarchy();

    if(roots.length===0){
      redraw(); return;
    }
    // If multiple roots, arrange them side-by-side and center them as a group.
    let xCursor = 0;
    let topY = 0;
    for(const r of roots){
      measureSubtree(r);
      placeSubtree(r, xCursor, topY);
      xCursor += r._subWidth + SIBLING_GAP_X;
    }

    // Sync computed positions back to nodes[]
    for(const n of nodes){
      const m = map.get(n.id);
      if(m){ n.x = m.x; n.y = m.y; }
    }

    // Draw all
    nodes.forEach(drawNode);
    edges.forEach(drawEdge);

    // Center the whole arrangement by viewBox fit
    fitViewBoxToContent();
    persist();
  }

  // ---------- Stage & toolbar ----------
  stage.addEventListener('click',(e)=>{ if(e.target===stage) clearSelection(); });
  btnConnect.addEventListener('click', ()=>{
    isConnecting = !isConnecting;
    connectAnchor = isConnecting ? selectedId : null;
    highlightConnecting(isConnecting);
  });

  btnAddParent.addEventListener('click', ()=>{
    const n = addNode({text:'Topic',type:'parent'});
    if(autoLayout){ layoutAndRedraw(); } else { drawNode(n); fitViewBoxToContent(); }
    editNode(n);
  });

  btnAddChild.addEventListener('click', ()=>{
    if(!selectedId) return;
    const c = addSubtopic(selectedId);
    if(autoLayout){ layoutAndRedraw(); } else { drawNode(c); addEdge(findNode(selectedId).id,c.id); redraw(); }
    editNode(c);
  });

  btnZoomFit.addEventListener('click', ()=> fitViewBoxToContent(80));
  btnReset.addEventListener('click', ()=>{ if(confirm('Clear the map?')) removeAll(); });
  btnExport.addEventListener('click', exportJSON);
  fileImport.addEventListener('change',(e)=>{ const f=e.target.files?.[0]; if(f) importJSON(f); e.target.value=''; });

  btnAutoLayout.addEventListener('click', ()=>{
    autoLayout = !autoLayout;
    if(autoLayout) layoutAndRedraw(); else redraw();
    updateButtons(); persist();
  });

  window.addEventListener('resize', ()=> fitViewBoxToContent());

  // ---------- Init ----------
  restore();
  if(nodes.length===0){
    const root = addNode({text:'Main Topic',type:'parent'});
    addSubtopic(root.id);
    layoutAndRedraw();
  }else{
    nodes.forEach(autosizeNode);
    if(autoLayout) layoutAndRedraw(); else { nodes.forEach(drawNode); edges.forEach(drawEdge); fitViewBoxToContent(); }
  }
})();
</script>
</body>
</html>
